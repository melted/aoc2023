(import (util))

(define data (read-lines-all "./data/input25.txt"))

(define (parse-data data)
  (define edges (make-hashtable equal-hash equal?))
  (define (parse-line str)
    (let ((parts (split-trim str ":")))
      (list (car parts) (split-trim (cadr parts) " "))))
  (define (has-edge? a b)
    (memq b (hashtable-ref edges a '())))
  (define (add-edge a b)
    (define (update n)
      (lambda (p)
        (cons n p)))
    (unless (or (has-edge? a b) (string=? a b))
      (hashtable-update! edges a (update b) '())
      (hashtable-update! edges b (update a) '())))
  (define (handle-one str)
    (define nodes (parse-line str))
    (for-each (lambda (v) (add-edge (car nodes) v)) (cadr nodes)))
  (for-each handle-one data)
  edges)

(define (count-components edges)
  (define nodes (make-hashtable equal-hash equal?))
  (define wanted (div (hashtable-size edges) 2))
  (define chosen (make-hashtable equal-hash equal?))
  (define seed (vector-ref (hashtable-keys edges) 0))
  (define (choose v)
    (hashtable-set! chosen v #t)
    (hashtable-delete! nodes v))
  (vector-for-each (lambda (v) (hashtable-set! nodes v #t)) (hashtable-keys edges))
  (let loop ((todo (list seed)) (acc '()))
    (cond 
      ((null? todo)
        (let ((new-acc (cons (hashtable-size chosen) acc)))
          (hashtable-clear! chosen)
          (if (= (hashtable-size nodes) 0)
              new-acc
            (loop (list (vector-ref (hashtable-keys nodes) 0)) new-acc))))
      (else
        (let* ((next (car todo))
               (conns (remp (lambda (x) (hashtable-contains? chosen x)) (hashtable-ref edges next '())))
               (work (append todo conns)))
          (choose next)
          (loop (cdr work) acc))))))

(define (search edges from to)
  (define seen (make-hashtable equal-hash equal?))
  (let loop ((routes (list (list from))) (next '()))
    (if (null? routes)
        (if (null? next)
            #f
            (loop next '()))
        (let* ((this (car routes))
               (conns (remp (lambda (x) (hashtable-contains? seen x)) (hashtable-ref edges (car this) '()))))
          (let-values (((finished ongoing) (partition (lambda (x) (string=? to x)) conns)))
            (let ((new-routes (map (lambda (x) (cons x this)) ongoing)))
              (for-each (lambda (x) (hashtable-set! seen x #t)) ongoing)
              (if (null? finished)
                  (loop (cdr routes) (append next new-routes))
                  (cons (car finished) this))))))))

(define (solve data)
  (define edges (parse-data data))
  (define nodes (hashtable-keys edges))
  (define size (vector-length nodes))
  (define popular (make-hashtable equal-hash equal?))
  (define (add-route route)
    (let loop ((r route))
      (if (or (null? r) (null? (cdr r)))
          void
          (let ((pair (list-sort string<? (list-head r 2))))
            (hashtable-update! popular pair add1 0)
            (loop (cdr r))))))
  (define (remove-edge pair)
    (define (update n)
      (lambda (p)
        (remove n p)))
    (hashtable-update! edges (car pair) (update (cadr pair)) '())
    (hashtable-update! edges (cadr pair) (update (car pair)) '()))
  (do ((i 0 (+ i 1)))
      ((= i 1000))
    (let ((a (vector-ref nodes (random size)))
          (b (vector-ref nodes (random size))))
      (add-route (search edges a b))))
  (let ((top3 (list-head
                 (list-sort (lambda (a b) (> (cdr a) (cdr b)))
                            (vector->list (hashtable-cells popular)))
                 3)))
    (for-each (lambda (x) (remove-edge (car x))) top3)
    (count-components edges)))
